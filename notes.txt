Записки за Пролог

SWI-Prolog винаги стартира някъде по дефолт, но това е различно от папката, където е репото. Всеки път трябва да си променям работната директория

? Да се провери дали може да се пренастрои да стартира в конкретна работна директория?

Тирета в имената на файловете би ги направило объркващи за импорт в swi. Нека да ползваме camel-case при именуване.

working_directory(CWD, CWD). - проверява коя ни е работната директория (при дебугването на проблема защо не вижда съществуващи файлове).

Ако напишем факт във файл и го заредим в пролог, то този факт се приема и оценява правилно.

? Защо ако напишем същия факт директно в конзолата на пролог получаваме грешка?

Ако използваме няколко факта изреденни със запетая, то тези факти се разглеждат като факти върху, които прилагаме логическо И.

Ако извикаме напирмер, parent(albert, _). ще получим истина, защото намира стойност, която и да е, за която можем да кажем, че алберт е
    нейн родител. Съответно, ще се оцени като лъжа, ако подадем като първи аргумент, обект, който няма деца.

Ако пуснем, например, horizontal(line(point(5,10), point(20, X)))., ще ни върне стойност на X, т.ч. да оцени израза с истина.
Ако пуснем същия код, но с долна черта, horizontal(line(point(5,10), point(20, _)))., ще ни върне оценка истина, ако намира
    стойност, която да отговори на условията, т.ч. целия израз да е истина.

Също така, ако имаме файл, в който дефинираме факти и alice е параметър във факт, то ако изпълним следното:
    ?- alice = alice.
    ?- alice = 'alice'.
    и в двата случая ще получим истина. Това е така, зашото alice е атом и няма значение дали ще е с единични кавички или
    ще бъде запписан без кавички.
    Ако обаче изпълним ?- alice = albert. ще получим лъжа, защото са два различни атома.
    ?- alice = ALICE. връща ALICE = alber, true. Това е така, защото променливите започват с главна буква или _ и съответно
    се присвоява атома на променлива.
    Според ресури от интернет, равенството в този случай работи като унификатор, който опитва да приравни двете стойности - на
        атома и променливата.

Стандартните операции +, -, *, /, сравнения >, <, <=, >= и тн ги изпълнаваме директно в конзолата и се оценяват на момента.
    Могат да се използват в предварително създаден файл и да се заредят в конзолата с [<име_на_файл>.pl].

? Защо операторите за сравнение <= и >= не работят както се очква като са подадени към функции, а вместо това хвърлят ексепшън ?

Нещо друго за променливите, ако изпъкним rich(money, X) = rich(Y, no_debt)., пролог ще ни даде следните стойности:
    * за X = no_debt
    * за Y = money
    * с уговорката, че това е изпълнено в конзолата. Няма пример какъв е резултата ако се сложи във файл.
        (Не виждам да има начин да се извика като е във файл, дори да се присвои на променлива)

Имаме инструмент trace, който е нешо като дебъгер за кода.
    * trace. го пуска.
    * с ентър минаваме на следвашата стъпка (може и с ;, но стъпките ще са с подобен формат mammal(human) ? Unknown option (h for help)),
        докато с ентър са mammal(human) ? creep.
        (Не ми е ясно каква е разликата)
    * Ако извикаме trace. и в този режим пуснем mammal(human)., то всяка стъпка на изпълнение ще бъде описана: 
        ** кога и в коя подфункция влиза
        ** кога приключва дадена функция
        ** рабира се, exit call-a на главната функция и статуса на функцията.
    * Примерен лог при истина:
        trace]  ?- mammal(human).
            Call: (12) mammal(human) ? creep
            Call: (13) warm_blooded(human) ? creep
            Exit: (13) warm_blooded(human) ? creep
            Call: (13) produce_milk(human) ? creep
            Exit: (13) produce_milk(human) ? creep
            Call: (13) have_hair(human) ? creep
            Exit: (13) have_hair(human) ? creep
            Exit: (12) mammal(human) ? creep
        true.
    * Примерен лог и когато е лъжа:
        [trace]  ?- mammal(penguin).
            Call: (12) mammal(penguin) ? Unknown option (h for help)
            Call: (12) mammal(penguin) ? Unknown option (h for help)
            Call: (12) mammal(penguin) ? Unknown option (h for help)
            Call: (12) mammal(penguin) ? creep
            Call: (13) warm_blooded(penguin) ? creep
            Exit: (13) warm_blooded(penguin) ? creep
            Call: (13) produce_milk(penguin) ? creep
            Exit: (13) produce_milk(penguin) ? creep
            Call: (13) have_hair(penguin) ? creep
            Fail: (13) have_hair(penguin) ? creep
            Fail: (12) mammal(penguin) ? creep
        false.
    * Как да излезем от дебъг режим ?- notrace.

Можем и да използваме по няколко факта на ведъж, изредени със запетаи като подадем една и съща променлива на всеки факт.
    Така пролог ще ни генерира отговори, които биха били подходяши стойности за променливата, т.ч. да оцени всички факти с истина.
    Например: warm_blooded(X), produce_milk(X), write(X), nl.
        Този пример ще ни принтира следното:
            ?- warm_blooded(X), produce_milk(X), write(X), nl.
            penguin
            X = penguin ;
            human
            X = human.

Време е да разгледаме и рекурсията в пролог код

Добавяне на файл в swi-Prolog:
- първи вариант, [<name_of_file>].
- втори вариант,  ensure_loaded('Seminar_7_8am-11am.pl').



