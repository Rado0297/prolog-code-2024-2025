% На пролог променливите не се декларират предварително.  Дали
% дадена дума е променлива или символ за индивидна константа,
% пролог разпознава по следния начин: променливите започват с
% главна буква, а константите – с малка.  Например X, Y0,
% Резултат са променливи, а x, n5 и софия са константи.

% Забележка: в литературата за пролог такива константи се наричат
% атоми.  Тук обаче няма да ги наричаме атоми, за да не би някой
% да си помисли, че има нещо общо между атом и атомарна формула.

% Клауза от вида
%    p(X) :- q(X,Y), r(Z).
% отговаря на следната логическа формула:
%    q(x,y) & r(z) ⇒ p(x)
% Но понеже пролог ще приеме, че тази клауза е тъждествено вярна,
% то всъщност имаме следната формула:
%    ∀x∀y(q(x,y) & r(z) ⇒ p(x))

% Пролог „приема“, че сме му казали истината, цялата истина и
% само истината.  Затова ако кажем например следните две клаузи
%    p(X) :- q(X).
%    p(X) :- r(X).
% и няма други клаузи, в които се говори кога е верен предикатът
% p, то пролог ще реши, че е вярно
%    ∀x(q(x) ∨ r(x) ⇔ p(x))
% въпреки че ние сме му казали не това, а само
%    ∀x(q(x) ∨ r(x) ⇒ p(x))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ФУНКЦИОНАЛЕН СТИЛ НА ПРОГРАМИРАНЕ НА ПРОЛОГ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% При фунционалните езици дефинираме функция f, за която
%       f(x,y)=z, където y е някакъв израз.
% Вместо това на пролог ще дефинираме предикат p, такъв че
%       p(x,y,z) е истина тогава и само тогава, когато f(x,y)=z

% За момента да считаме (макар че не е точно така), че на пролог
% има един тип данни: термове, т.е. изрази.  Например = е
% равенство между изрази, а не равенство между числа.  Затова

%% ?- 1+2=3.
%% false.

%% ?- 1+2=1+X.
%% X = 2.

% Едно уникално и забележително от теоретична гледна точка
% свойство на пролог е това, че дори да го лишим от абсолютно
% всички вградени предикати, езикът продължава да бъде
% използваем.  Например естествените числа може да ги представим
% по следния начин:
%
%   - нулата ще представяме посредством символа 0 (разбира се тук
%     0 е символ за индивидна константа, а не число)
%   - числото n+1 ще представяме с терма s(n).
%
% Например числото 3 ще представяме посредством терма s(s(s(0)).
%
% След като сме избрали представяне на естествените числа
% посредством термове, не е проблем да дефинираме предикати за
% различните аритметични операции.  Например събирането може да
% дефинираме така:

% сбор(N,M,K) - К е сбор на естествените числа N и M

сбор(0,X,X).
сбор(s(X),Y,s(Z)) :- сбор(X,Y,Z).

%% ?- сбор(s(s(0)), s(s(s(s(0)))), Сбор).
%% Сбор = s(s(s(s(s(s(0)))))).


% Да дефинираме предикат за символно диференциране.  Засега да
% считаме, че типът данни, с които работи пролог, е типът „терм“.
% Разбира се аритметичните изрази са термове от специален вид,
% така че можем да работим с тях директно без да се налага да
% дефинираме собствени типове.

% dx(F,DF) - DF е производна на F по x (F е израз на реална
%            функция)

dx(0,0).  dx(1,0).  dx(2,0).  dx(3,0).  dx(e,0).

% dx(X, 1) би казало, че производната на всяка функция е 1.  Имаме
% нужда от нещо, което за нас е променлива, но за пролог не е.
% Затова използваме x вместо X
dx(x,1).
dx(y,0).  dx(z,0).  dx(t,0).  dx(u,0).  dx(v,0).  dx(w,0).

dx(F+G,DF+DG) :- dx(F,DF), dx(G,DG).
dx(F-G,DF-DG) :- dx(F,DF), dx(G,DG).
dx(F*G,F*DG+G*DF) :- dx(F,DF), dx(G,DG).
dx(F/G,(DF*G-DG*F)/(G^2)) :- dx(F,DF), dx(G,DG).
dx(F^2,2*F*DF) :- dx(F,DF).
dx(-F,-DF) :- dx(F,DF).
dx(sin(F),cos(F)*DF) :- dx(F,DF).
dx(cos(F),-sin(F)*DF) :- dx(F,DF).
dx(ln(F),DF/F) :- dx(F,DF).
dx(e^F,DF*(e^F)) :- dx(F,DF).

% Да пробваме как работи така дефинираният предикат:

%% ?- dx(x+y+z+1+t+0, F).
%% F = 1+0+0+0+0+0.
%%
%% ?- dx(sin(cos(x)),F).
%% F = cos(cos(x))*(-sin(x)*1).
%%
%% ?- dx(x+cos(x+y)*z-1/t+0, F).
%% F = 1+(cos(x+y)*0+z*(-sin(x+y)*(1+0)))-(0*t-0*1)/t^2+0.

% Производната на израза e^2 можем да сметнем по два начина: като
% производна на F^2 и като производна на e^F.  Затова след като даде
% първия отговор компютърът чака без да отпечатва на следващия ред
% подсказката ?-.  Ако искаме да получим друг отговор, трябва да
% натиснем клавиша «;».

%% ?- dx(e^2,F).
%% F = 2*e*0 ;
%% F = 0*e^2.

% Получихме верни отговори, но изразите са сложни и очевидно има
% начин да се опростят.  Да дефинираме предикат за опростяване на
% израз.

% Най-напред да даучим пролог на някои формули за опростяване на
% изрази.

% формула(F,G) - изразът F може да се опрости до G

формула(X+0,X).
формула(0+X,X).
формула(X-0,X).
формула(0-X,-X).
формула(_X*0,0).
формула(0*_X,0).
формула(X*1,X).
формула(1*X,X).
формула(0/_,0).
формула(X/1,X).
формула(_^0,1).
формула(0^_,0).
формула(1^_,1).
формула(X^1,X).
формула(X+1,1+X).
формула(X+2,2+X).
формула(X+3,3+X).
формула(X+e,e+X).
формула(X*2,2*X).
формула(X*3,3*X).
формула(X*e,e*X).
формула(X+X,2*X).
формула(X-X,0).
формула((F+X)-X,F).
формула((F-X)+X,F).
формула((F+X)+X,F+2*X).
формула(X*X,X^2).
формула((F*X)*X,F*X^2).
формула(1+1,2).
формула(1+2,3).
формула(2+1,3).

формула(X+(Y+Z), (X+Y)+Z).
формула(X*(Y*Z), (X*Y)*Z).
формула(X*(Y+Z), X*Y+X*Z).
формула((Y+Z)*X, Y*X+Z*X).
формула(X*(Y-Z), X*Y-X*Z).
формула((Y-Z)*X, Y*X-Z*X).
формула(-(X+Y), (-X)+(-Y)).
формула(-(-X),X).
формула(X+(-Y),X-Y).
формула(X-(-Y),X+Y).
формула((-X)+Y,Y-X).
формула((-X)*Y,-(X*Y)).
формула(X*(-Y),-(X*Y)).
формула((-X)/Y,-(X/Y)).
формула(X/(-Y),-(X/Y)).
формула((F+G)^2,F^2+2*F*G+G^2).
формула((F-G)^2,F^2-2*F*G+G^2).
формула((F*G)^2,(F^2)*(G^2)).

% едностъпково_опростяване(F, G) - изразът G се получава след
%                                  еднократно прилагане на някоя от
%                                  горните формули към F

% Tук прилагаме предиката формула към целия израз F.
% Например (x+y)+0 ще се опрости до x+y.
едностъпково_опростяване(F,G) :- формула(F,G).

% Сега да приложим предиката в дълбочина.  Например (x+0)+y ще се
% опрости до x+y.  Имаме по една клауза за всяка унарна операция и по
% две клаузи за всяка бинарна операция.
едностъпково_опростяване(F+H,G+H) :-
    едностъпково_опростяване(F,G).
едностъпково_опростяване(H+F,H+G) :-
    едностъпково_опростяване(F,G).
едностъпково_опростяване(F*H,G*H) :-
    едностъпково_опростяване(F,G).
едностъпково_опростяване(H*F,H*G) :-
    едностъпково_опростяване(F,G).
едностъпково_опростяване(F-H,G-H) :-
    едностъпково_опростяване(F,G).
едностъпково_опростяване(H-F,H-G) :-
    едностъпково_опростяване(F,G).
едностъпково_опростяване(F/H,G/H) :-
    едностъпково_опростяване(F,G).
едностъпково_опростяване(H/F,H/G) :-
    едностъпково_опростяване(F,G).
едностъпково_опростяване(H^F,H^G) :-
    едностъпково_опростяване(F,G).
едностъпково_опростяване(-F1,-G1) :-
    едностъпково_опростяване(F1,G1).
едностъпково_опростяване(ln(F1),ln(G1)) :-
    едностъпково_опростяване(F1,G1).
едностъпково_опростяване(sin(F1),sin(G1)) :-
    едностъпково_опростяване(F1,G1).
едностъпково_опростяване(cos(F1),cos(G1)) :-
    едностъпково_опростяване(F1,G1).

% Да пробваме:

%% ?- опростяване(1+0*x,F).
%% F = 1.

%% ?- опростяване(1+0*x+0,F).
%% F = 1.

%% ?- опростяване((1+0*x+0)*(1+0),F).
%% F = 1.

%% ?- опростяване((1+0*x+0)*(1+0)+1,F).
%% F = 2.

% Да забележим, че чрез предиката редукция дефинираме многозначна
% функция, защото за един израз може да има много начини, по
% които той може да бъде опростен.  Например изразът x+0+y+0+x+0
% може да бъде опростен едностъпково по три различни начина:

%% ?- едностъпково_опростяване(x+0+y+0+x+0, F).
%% F = x+0+y+0+x ;
%% F = x+0+y+x+0 ;
%% F = x+y+0+x+0 ;
%% false.

% Една многозначна функция може да има и нула на брой стойности.
% Тъй като нямаме формула, която да казва, че 2+2 е равно на 4,
% то изразът 2+2 няма да може да се опрости:

%% ?- едностъпково_опростяване(2+2, F).
%% false.

% Всъщност макар това да няма значение за конкретно решаваната
% задача, да отбележим, че сме дефинирали на пролог двуместен
% предикат, а не функция.  Никъде не сме казвали, че първият аргумент
% е аргументът на функцията, а вторият – резултатът.  И наистина,
% предикатът едностъпково_опростяване може да се изпълнява и
% наобратно.  Да попитаме например кои изрази се опростяват
% едностъпково до израза 2:

%% ?- едностъпково_опростяване(F,2).
%% F = 2+0 ;
%% F = 0+2 ;
%% F = 2-0 ;
%% F = 2*1 ;
%% F = 1*2 ;
%% F = 2/1 ;
%% F = 2^1 ;
%% F = 2+_10-_10 ;
%% F = 2-_11+_11 ;
%% F = 1+1 ;
%% F = - - 2 ;
%% false.

% „Условен оператор“ на пролог:

% ( F -> G ; H) :- if F then G else H.

% Този „предикат“ може да се използва само когато програмираме
% функционално.  Когато програмираме логически, е възможно стойността
% на F все още да не бъде известна и затова условният оператор няма
% да работи коректно.  Един лош дефект на пролог е това, че
% компилаторът няма да ни предупреди, че се е случила грешка (въпреки
% че при правилно направен компилатор, това е възможно).  Вместо да
% се получи съобщение за грешка, програмата просто ще работи
% неправилно.  Този дефект се дължи на древността на езика пролог и
% се проявява не само тук, но и в други ситуации.


% опростяване(F, G) - изразът G се получава след прилагане на
%                     едностъпкови опростявания към F докато може

опростяване(F,G) :-
    (  едностъпково_опростяване(F,F1)
    -> опростяване(F1,G)
    ;  F = G).

% Този предикат прави едностъпкови опростявания на израза докато
% може, а не само веднъж.  Например в израза x+0+y+0+x+0 ще махне
% не една, а всички нули:

%% ?- опростяване(x+0+y+0+x+0, F).
%% F = x+y+x.

% Да видим как ще се опростят производните, които по-горе
% сметнахме:

%% ?- dx(x+y+z+1+t+0,F), опростяване(F,G).
%% F = 1+0+0+0+0+0,
%% G = 1.

%% ?- dx(sin(cos(x)),F), опростяване(F,G).
%% F = cos(cos(x))*(-sin(x)*1),
%% G = - (cos(cos(x))*sin(x)).

%% ?- dx(x+cos(x+y)*z-1/t+0, F), опростяване(F,G).
%% F = 1+(cos(x+y)*0+z*(-sin(x+y)*(1+0)))-(0*t-0*1)/t^2+0,
%% G = 1-z*sin(x+y).

%% ?- dx(e^2,F), опростяване(F,G).
%% F = 2*e*0,
%% G = 0

%%%%%%%%%%%%%%%%%
% СПИСЪЦИ
%%%%%%%%%%%%%%%%%

% Понеже на пролог работим с изрази, то на теория няма нужда от
% списъци.  Може да си мислим, че f(1,f(2,f(3,c))) е списъкът
% [1,2,3], а c е списъкът [].

% В израза f(X,Y) X е първият елемент и се нарича глава на
% списъка; Y е опашката - списък от останалите елементи

% Въпреки че на теория няма нужда от списъци, езикът пролог
% поддържа по-четлив синтаксис:

% вместо f(X,Y) пишем [X|Y]
% вместо f(1,f(2,f(3,c))) пишем [1,2,3]
% вместо c пишем []

% Примери:

%% ?- [A|X] = [1,2,3,4].
%% A = 1,
%% X = [2, 3, 4].

%% ?- [A,B|Y] = [1,2,3,4].
%% A = 1,
%% B = 2,
%% Y = [3, 4].

%% ?- [A,B,C,D|Y] = [1,2,3,4].
%% A = 1,
%% B = 2,
%% C = 3,
%% D = 4,
%% Y = [].

%% ?- [A,B,C,D,E|Y] = [1,2,3,4].
%% false.

% Ще спазвам следната уговорка за имената на променливите:

% за списъци: X, Y, Z
% за елементи: A, B, C
% списък от списъци: XX, YY, ZZ


% елемент(A,X) - А е елемент на спъсъка X
% Вграден е в езика като member(A,X)
%
% Условие: известно е ограничение отгоре за дължината на X

% Предикатът може да се дефинира на един ред така:

елемент2(A,[B|X]) :- A = B ; елемент2(A,X).

% Тук ; е дизюнкция.  Счита се обаче, че по-добър стил на
% програмиране е, ако такива дизюнкции разделим на две клаузи по
% следния начин:

елемент(A,[A|_]).
елемент(A,[_|X]) :- елемент(A,X).

% Вярно ли е, че 5 е елемент на [1,2,3]?
%% ?- елемент(5, [1,2,3]).
%% false.

% Вярно ли е, че 2 е елемент на [1,2,3]?
%% ?- елемент(2, [1,2,3]).
%% true 

% Кои са елементите на [1,2,3]?
%% ?- елемент(B, [1,2,3]).
%% B = 1 ;
%% B = 2 ;
%% B = 3 ;
%% false.

% Кои са всички триелементни списъци, които съдържат а, б и в?
%% ?- X=[_,_,_], елемент(а, X), елемент(б, X), елемент(в, X).
%% X = [а, б, в] ;
%% X = [а, в, б] ;
%% X = [б, а, в] ;
%% X = [в, а, б] ;
%% X = [б, в, а] ;
%% X = [в, б, а] ;
%% false.

% При логическото програмиране имаме следната гаранция:
%
%%%% Ако казваме на компютъра верни неща, тогава и той няма да ни
%%%% лъже.
%
% От тук следва, че ако всяка от клаузите, които сме казали на
% компютъра, са верни съждения, тогава
%
% 1. Ако компютърът даде някой отговор, тогава този отговор ще бъде
%    верен.
% 2. Ако компютърът каже, че няма повече отговори (т.е. след като ни
%    е дал някакви отговори, отговори с false), то значи наистина
%    няма повече отговори.
%
% В теоретичната информатика за една програма или алгоритъм се
% дефинират т.н. „частична коректност“ и „пълна коректност“.
% Частична коректност имаме тогава, когато отговорите, които
% програмата или алгоритъмът дава, винаги са верни.  Пълна коректност
% пък имаме тогава, когато алгоритъмът или програмата никога не
% зациклят, т.е. винаги след крайно време дават отговор.
%
% При традиционния начин за програмиране е трудно да се доказва
% частичната коректност.  Това е така, защото модулите на програмата
% (класове/методи/функции) са взаимодействат по много сложен начин,
% така че не можем да разсъждаваме локално – например да гледаме само
% кратката дефиниция на някоя функция без да се интересуваме какво
% има в останалата част от програмата.  За сметка на това обаче, ако
% вече сме установили частичната коректност, пълната се получава
% много лесно.  Най-често е очевидно че алгоритъмът или програмата не
% се зациклят, а ако не е очевидно, то доказателството не е сложно.
%
% Едно много хубаво свойство на логическото програмиране е това, че
% частичната коректност се получава много лесно – просто гледаме дали
% клаузите в програмата са верни.  За да докажем, че дадена клауза е
% вярна, изобщо не е нужно да знаем какви други клаузи има в
% програмата.  Следователно при логическото програмиране при
% доказателството на частичната коректност можем да разсъждаваме
% локално.
%
% За сметка на това обаче при логическото програмиране не можем да
% игнорираме въпроса за пълната коректност.  Разсъжденията за
% доказателство на пълната коректност не са сложни, но не могат да се
% изпускат.  Това е така, защото докато за една традиционна програма
% или алгоритъм е обичайно да се окаже, че винаги дават резултат, при
% предикатите на пролог това почти никога не се случва.  Следователно
% за всеки предикат в нашата програма трябва да определим някакво
% условие, което ако е изпълнено, използването на предиката ще бъде
% коректно.
%
% Да видим как можем да докажем коректността на предиката елемент.
% Най-напред да установим частичната коректност.  За целта си
% „превеждаме“ двете клаузи от дефиницията на елемент на български
% език и се уверяваме, че се получават верни съждения:
%
% елемент(A,[A|_]).
%
%     За всяко A  A е елемент на кой да е списък от вида [A|_].
%
% елемент(A,[_|X]) :- елемент(A,X).
%
%     Ако A е елемент на списъка X, то A е елемент на кой да е списък
%     от вида [_|X].
%
% Очевидно и двете твърдения са верни.  Сега да видим как проверяваме
% пълната коректност – това, че пролог няма да зацикли.  Или
% по-точно, какви условия трябва да са изпълнени, за да е сигурно, че
% пролог няма да зацикли.
%
% Да разгледаме клауза от вида p :- q1,q2,...,qn.  При
% доказателството, че пролог не зацикля, считаме, че такава клауза
% работи процедурно по следния начин: за да се изпълни p, най-напред
% се изпълнява q1, после q2, после q3, и т.н., накрая изпълняваме qn.
% Фактите не ни интересуват, защото те никога не могат да доведат до
% зацикляне.
%
% Конкретно при предиката елемент не ни интересува фактът
%
%     елемент(A,[A|_]).
%
% Интересува ни само правилото
%
%     елемент(A,[_|X]) :- елемент(A,X).
%
% Виждаме, че при рекурсивното извикване на елемент от елемент
% първият аргумент от A става A.  T.e. първият аргумент не се променя
% и значи не ни помага рекурсията да бъде крайна.  Вторият аргумент
% от [_|X] става X.  Следователно вторият аргумент си намалява
% дължината.  Може ли един списък (подразбира се краен списък) до
% безкрайност да си намалява дължината?  В логическото програмира не
% може, защото в логическото програмиране може да работим с
% неизвестни или частично известни данни.  За да сме сигурни, че един
% списък не може да си да си намалява дължината до безкрай, е нужно
% да знаем ограничение отгоре за дължината на този списък.  Именно
% това ще бъде и условието за коректност на предиката елемент(А,X) -
% че е известно ограничение отгоре за дължината на X.


% конкат(X,Y,Z) - Z е конкатенация на X и Y
%
% Условие: известно е ограничение отгоре за дължината на X или за
%          дължината на Z

конкат([],Z,Z).
конкат([A|X],Y,[A|Z]) :- конкат(X,Y,Z).

% Да изведем условието за пълна коректност.  Отново фактът
% конкат([],Z,Z) не ни интересува.  Интересува ни единствено
% правилото.  При него имаме рекурсивно извикване като първият и
% третият аргумент си намаляват дължината.  Вторият аргумент остава
% същият и затова не ни помага рекурсията да бъде крайна.
% Следователно условието за коректност на конкат е: „известно е
% ограничение отгоре за дължината на първия или за дължината на
% третия аргумент.“

% Някои примери.  Уверете се, че във всеки от тях е изпълнено
% условието за коректност.

% Намираме конкатенацията на два известни списъка:
%% ?- конкат([1,2],[3,4,5],Z).
%% Z = [1, 2, 3, 4, 5].

% Какво конкатенирано с [3,4,5] дава [1,2,3,4,5]?
%% ?- конкат(X,[3,4,5],[1,2,3,4,5]).
%% X = [1, 2] ;
%% false.

% Кои X и Y след като ги конкатенираме дават [1,2,3,4,5]?
%% ?- конкат(X,Y,[1,2,3,4,5]).
%% X = [],
%% Y = [1, 2, 3, 4, 5] ;
%% X = [1],
%% Y = [2, 3, 4, 5] ;
%% X = [1, 2],
%% Y = [3, 4, 5] ;
%% X = [1, 2, 3],
%% Y = [4, 5] ;
%% X = [1, 2, 3, 4],
%% Y = [5] ;
%% X = [1, 2, 3, 4, 5],
%% Y = [] ;
%% false.

% Пример за въпрос без верен отговор:
%% ?- конкат([1,2,3],X,[1,5,3]).
%% false.

%% ?- конкат(X,[1|Y],[1,2,3]).
%% X = [],
%% Y = [2, 3] 

% предпоследен(X, A) - А е предпоследният елемент на списъка X
%
% Условие: известно е ограничение отгоре за дължината на X

предпоследен(X, A) :- конкат(_, [A,_], X).

%% ?- предпоследен([1,2,3,4,5], A).
%% A = 4 

% ЗАБЕЛЕЖКА. Няма смисъл по аналогичен начин да дефинираме предикат
% за намиране на втория елемент.  Вторият елемент на списък X можем
% да намерим така: [_,A|_] = X.

% префикс(X,Y) - списъкът X е начало на списъка Y
%
% Условие: известно е ограничение отгоре за дължината на X или за
%          дължината на Y

префикс(X,Y) :- конкат(X,_,Y).

%% ?- префикс(X,[1,2,3]).
%% X = [] ;
%% X = [1] ;
%% X = [1, 2] ;
%% X = [1, 2, 3] ;
%% false.

% Интересно е, че съгласно изведеното условие за коректност,
% предикатът трябва да работи вярно (в частност няма да намира
% безброй отговори) на въпроса на кои списъци [1,2,3] е префикс.  Как
% е възможно това при положение, че има безброй много такива списъци?
% Да видим:

%% ?- префикс([1,2,3],X).
%% X = [1, 2, 3|_492].

% суфикс(X,Y) - списъкът X е край на Y
%
% Условие: известно е ограничение отгоре за дължината на Y

суфикс(X,Y) :- конкат(_,X,Y).

%% ?- суфикс(X,[1,2,3]).
%% X = [1, 2, 3] ;
%% X = [2, 3] ;
%% X = [3] ;
%% X = [] ;
%% false.

% инфикс(X,Y) - Х e отрез от списъка Y
%
% Условие: имаме четири варианта, всеки със собствено условие за
%          коректност.

% Това работи, ако е известна дължината и на X, и на Y
инфикс1(X,Y) :- префикс(X,L),суфикс(L,Y).
% Това никога не работи
инфикс2(X,Y) :- суфикс(X,L),префикс(L,Y).

% И двете дефиниции нямат хубави условия за коректност и затова не
% работят така, както ни се иска:

%% ?- инфикс1(X,[1,2]).
%% X = [] ;
%% X = [] ;
%% X = [] ;
%% X = [1] ;
%% X = [2] ;
%% X = [1, 2] ;
%%   C-c C-cAction (h for help) ? a
%% abort
%% % Execution Aborted
%% ?- инфикс2(X,[1,2]).
%% X = [] ;
%% X = [1] ;
%% X = [1, 2] ;
%% X = [] ;
%% X = [2] ;
%% X = [] ;
%% ERROR: Out of global-stack.
%% ERROR: No room for exception term.  Aborting.
%% % Execution Aborted

% Да разменим двата члена на горните конюнкции.  От инфикс1
% получаваме инфикс3 и от инфикс2 получаваме инфикс4:

% Това работи, ако е известно ограничение отгоре за дължината на Y
инфикс3(X,Y) :- суфикс(L,Y),префикс(X,L).
% Това работи, ако е известно ограничение отгоре за дължината на Y
инфикс4(X,Y) :- префикс(L,Y),суфикс(X,L).

% Тези предикати работят добре:

%% ?- инфикс3(X,[1,2]).
%% X = [] ;
%% X = [1] ;
%% X = [1, 2] ;
%% X = [] ;
%% X = [2] ;
%% X = [] ;
%% false.

%% ?- инфикс4(X,[1,2]).
%% X = [] ;
%% X = [1] ;
%% X = [] ;
%% X = [1, 2] ;
%% X = [2] ;
%% X = [] ;
%% false.

% Поуката от горното е това, че конюнкцията (за разлика от
% дизюнкцията) не е комутативна.  Конюнктивните членове се изпълняват
% последователно един след друг, така че в зависимост от реда на
% изпълнение се променят и условията за коректност на предиката.

% При логическия език за програмиране Mercury клаузите изглеждат
% подобно на клаузите на пролог.  Освен това даваме и допълнителни
% подсказки на компилатора.  В резултат на това в този език също и
% конюнкцията е комутативна операция, а и компилираната програма се
% изпълнява доста по-бързо, отколкото при пролог.

% четни(X,Y) - Y е списък от елементите на X, които са на четна
%              позиция
%
% Условие: известно е ограничение отгоре за дължината на X или за
%          дължината на Y

четни([],[]).
четни([_|X],Y) :- нечетни(X,Y).

% нечетни(X,Y) - Y е списък от елементите на X, които са на нечетна
%                позиция
%
% Условие: известно е ограничение отгоре за дължината на X или за
%          дължината на Y

нечетни([],[]).
нечетни([A|X],[A|Y]) :- четни(X,Y).

% При тези два предиката рекурсията е взаимна.  Доказателството за
% пълна коректност обаче се прави по подобен начин.  Отново не се
% интересуваме от фактите.  Интересуват ни само двете правила:
%
%%   четни([_|X],Y) :- нечетни(X,Y).
%%   нечетни([A|X],[A|Y]) :- четни(X,Y).
%
% Виждаме, че:
%
% 1. При предиката четни първият аргумент си намалява дължината, а
%    вторият – не.
% 2. При предиката нечетни и двата аргумента си намаляват дължината.
%
% Следователно за да бъде рекурсията крайна е достатъчно да бъде
% известна дължината на поне един от аргументите.  Например ако е
% известна дължината на втория аргумент, четни ще извика нечетни със
% същия аргумент, нечетни ще намали дължината и ще извика четни,
% четни пак ще извика нечетни със същия списък, а нечетни ще извика
% четни с по-къс списък.  Следователно макар и не при всяко
% рекурсивно извикване, вторият аргумент все пак си намалява
% дължината до безкрай, а това не може да се случи, ако е известно
% ограничение отгоре за дължината.

% Проби:

%% ?- четни([1,2,3,4,5],X).
%% X = [2, 4].

%% ?- четни(X,[1,2,3]), нечетни(X,[а,б,в,г]).
%% X = [а, 1, б, 2, в, 3, г].

%% ?- четни(X,[1,2,3]).
%% X = [_2832, 1, _2844, 2, _2856, 3] ;
%% X = [_2832, 1, _2844, 2, _2856, 3, _3530].

% ротация(X, Y) - списъкът Y е ротация на списъка X
%
% Условие: известно е ограничение отгоре за дължината на X

ротация(X, Y) :- конкат(X1, X2, X), конкат(X2, X1, Y).

% Генериране на музикалните ладове
%% ?- ротация([до,ре,ми,фа,сол,ла,си], X).
%% X = [до, ре, ми, фа, сол, ла, си] ;    % йонийски лад
%% X = [ре, ми, фа, сол, ла, си, до] ;    % дорийски лад
%% X = [ми, фа, сол, ла, си, до, ре] ;    % фригийски лад
%% X = [фа, сол, ла, си, до, ре, ми] ;    % лидийски лад
%% X = [сол, ла, си, до, ре, ми, фа] ;    % миксолидийски лад
%% X = [ла, си, до, ре, ми, фа, сол] ;    % еолийски лад
%% X = [си, до, ре, ми, фа, сол, ла] ;    % локрийски лад
%% X = [до, ре, ми, фа, сол, ла, си] ;    % йонийски лад
%% false.


%%%%%%%%%%%%%%%%%%%%%%%%
% ПЕРМУТАЦИЯ
%%%%%%%%%%%%%%%%%%%%%%%%

% пермутация(X,Y) - Y е пермутация на списъка X
%
% Условие: известно е ограничение отгоре за дължината на X

пермутация([],[]).
пермутация([A|X], Z) :- пермутация(X,Y), вмък(A,Y,Z).

% вмък(A,X,Y) - Y се получава като вмъкнем A в X на произволна
%               позиция
%
% Условие: известно е ограничение отгоре за дължината на X или за
%          дължината на Y

% I случай: вторият аргумент е []
вмък(A,[],[A]).
% II случай: вторият аргумент не е [] има два подслучая:
вмък(A,[B|X],[A,B|X]).
вмък(A,[B|X],[B|Y]) :- вмък(A,X,Y).

% Втори начин:

вмък2(A,X,[A|X]).
вмък2(A,[B|X],[B|Y]) :- вмък2(A,X,Y).

% Проби:

%% ?- вмък(1,[а,б,в],X).
%% X = [1, а, б, в] ;
%% X = [а, 1, б, в] ;
%% X = [а, б, 1, в] ;
%% X = [а, б, в, 1] ;
%% false.

%% ?- вмък(1,X,[а,1,б,в,1]).
%% X = [а, б, в, 1] ;
%% X = [а, 1, б, в] ;
%% false.

%% ?- вмък(A,X,[1,2,3]).
%% A = 1,
%% X = [2, 3] ;
%% A = 2,
%% X = [1, 3] ;
%% A = 3,
%% X = [1, 2] ;
%% false.

%% ?- пермутация([а,б,в],X).
%% X = [а, б, в] ;
%% X = [б, а, в] ;
%% X = [б, в, а] ;
%% X = [а, в, б] ;
%% X = [в, а, б] ;
%% X = [в, б, а] ;
%% false.

%%%% Втори начин %%%%

% пермутация2(X,Y) - Y е пермутация на X (II начин)
%
% Условие: известно е ограничение отгоре за дължината на X

пермутация2([],[]).
пермутация2(X, [A|Y]) :- измък(X,A,Z), пермутация2(Z,Y).

% измък(X,A,Z) - Z се получава след като махнем елемент A от X
%
% Условие: известно е ограничение отгоре за дължината на X или
%          дължината на Z

измък(X,A,Z) :- вмък(A,Z,X).

% равна_дължина(X,Y) - X и Y са списъци с равна дължина
%
% Условие: известно е ограничение отгоре за дължината на X или за
%          дължината на Y

% Проби:

%% ?- пермутация2([а,б,в],X).
%% X = [а, б, в] ;
%% X = [а, в, б] ;
%% X = [б, а, в] ;
%% X = [б, в, а] ;
%% X = [в, а, б] ;
%% X = [в, б, а] ;
%% false.

% Условието за коректност на предикатите пермутация и пермутация2 не
% позволяват те да се използват наобратно:

%% ?- пермутация2(X,[а,б,в]).
%% X = [а, б, в] ;
%% ERROR: Out of global-stack.
%% ERROR: No room for exception term.  Aborting.

% Да поправим този дефект (макар че на практика много рядко има
% смисъл да правим такива поправки).  За целта най-напред ще
% дефинираме един помощен предикат:

равна_дължина([],[]).
равна_дължина([_|X],[_|Y]) :- равна_дължина(X,Y).

% Посредством предиката равна_дължина можем да направим вариант на
% предиката пермутация, който може да намира пермутации не само на
% първия аргумент, но също и на втория аргумент.

% симетрична_пермутация(X,Y) - Y е пермутация на X
%
% Условие: известно е ограничение отгоре за дължината на X или за
%          дължината на Y

симетрична_пермутация(X,Y) :- равна_дължина(X,Y), пермутация2(X,Y).

% Някои може би неефективни, но кратки дефиниции на елемент:

елемент3(A,X) :- вмък(A,_,X).
елемент4(A,X) :- измък(X,A,_).
елемент5(A,X) :- пермутация(X,[A|_]).
елемент6(A,X) :- инфикс([A],X).
елемент7(A,X) :- конкат(_,[A|_],X).
елемент8(A,X) :- суфикс([A|_],X).

%%%%%%%%%%%%%%%%%%%%%%%%%
% ЦЕЛОЧИСЛЕНА АРИТМЕТИКА
%%%%%%%%%%%%%%%%%%%%%%%%%

% Когато използваме суи пролог, за да заредим библиотеката за целочислена
% аритметика, добавяме към програмата следния ред:

:- use_module(library(clpfd)).

% Първоначално пролог е създаден като безтипов език.  Или по-точно като
% език, в който единственият тип данни е „терм“ (също както например на лисп
% и скийм единственият тип данни е „списък“).  С други думи на пролог
% дефинираме ербранова структура, чийто единствен носител е множеството от
% всички термове без променливи.

% Когато се използва библиотеката за целочислена аритметика (както и други
% подобни библиотеки), програмата на пролог вече дефинира не ербранова
% структура, а двусортна структура с два носителя.  Първият носител е
% множеството от термовете без променливи (който го имаме и без тази
% библиотека).  Вторият носител е множеството от целите числа.  С други думи
% вече имаме не един, а два примитивни типа: израз (т.е. терм) и цяло число.

% Въпреки че структурата на програмата става двусортна, пролог е проектиран
% като безтипов език, т.е. като език за едносортна структура.  Това води до
% някои неудобства.  Едно от тях е това, че типът на изразите в програмата
% се определя от името на предиката.  Например предикатът = е равенство
% между термове, следователно стойностите на изразите от двете страни на =
% са термове.  Аритметичният предикат за равенство е #=.  При него
% стойностите на изразите от двете страни на равенството са цели числа.
% Примери:

%% ?- 1 + 2 = K.
%% K = 1+2.

%% ?- 1 + 2 #= K.
%% K = 3.

%% ?- 1 + K #= 10.
%% K = 9.

%% ?- 1 + 3*K #= 10.
%% K = 3.

%% ?- 1 + 2*K #= 10.
%% false.

% Ето някои от предикатите в библиотеката за целочислена аритметика:

% X #= Y       X е равно на Y
% X #\= Y      X е различно от Y
% X #> Y       X е по-голямо от Y
% X #< Y       X е по-малко от Y
% X #>= Y      X е по-голямо или равно от Y
% X #=< Y      X е по-малко или равно от Y
% X #<= Y      грешка

% дължина(X, N) - N е дължината на X
%
% Условие: Известно е ограничение отгоре за дължината на X или
%          ограничение отгоре за стойността на N

% Така не става, защото никъде не казваме на компютъра, че работим с
% числа, а не с изрази:
дълж([],0).
дълж([_|X],N+1) :- дълж(X,N).

%% ?- дълж([а,б,в],N).
%% N = 0+1+1+1.

% Ето така действително ще можем да смятаме дължината на списък:
%
%% дължина([],N) :- N #= 0.
%% дължина([_|X],N) :- N #> 0, дължина(X,N-1).

%% ?- дължина([а,б,в],N).
%% N = 3.

% Да анализираме какво е условието за незацикляне на тази дефиниция.
% Първата клауза в горната дефиниция свежда към предиката за
% ограничение #=, така че не може да доведе до зацикляне и не ни
% интересува.  Във втората клауза първият аргумент при рекурсивното
% извикване си намалява броя на елементите.  Следователно едно
% условие за пълна коректност е да бъде известно ограничение отгоре
% за броя на елементите на първия аргумент.  Вторият аргумент пък си
% намалява стойността.  Може ли това да става до безкрайност?  В
% момента няма нищо, което да подскаже на компютъра, че дължината не
% може да бъде отрицателно число, така че да – дължината може да
% намалява до безкрайност.  Със съвсем малка подсказка този дефект
% може да се поправи:

дължина([],N) :- N #= 0.
дължина([_|X],N) :- N #> 0, дължина(X,N-1).

% Ще стане малко по-бързо, ако преработим втория ред по следния начин
% (но обикновено това не ни интересува):
%
%% дължина([_|X],N) :- N #>= 0, N-1 #= M, дължина(X,M).

% Така поправеният предикат можем да използваме не само за намиране
% дължината на спъсък, но също и за намиране на списък по дадена
% дължина:

% Да попитаме кой списък е с дължина 4:

%% ?- дължина(X, 4).
%% X = [_5544482, _5544648, _5544814, _5544980] ;
%% false.

% Да попитаме кои списъци са с дължина по-малка от 4:

%% ?- N #< 4, дължина(X, N).
%% N = 0,
%% X = [] ;
%% N = 1,
%% X = [_5548588] ;
%% N = 2,
%% X = [_5548588, _5550320] ;
%% N = 3,
%% X = [_5548588, _5550320, _5552566] ;
%% false.

% Вярно ли е, че [1,2,3,4] е с четна дължина?

%% ?- дължина([1,2,3,4], 2*K).
%% K = 2.

% Вярно ли е, че [1,2,3,4] е с нечетна дължина?

%% ?- дължина([1,2,3,4], 2*K+1).
%% false.

% сума(X, N) - N е сумата на елементите на X
%
% Условие: Известно е ограничение отгоре за дължината на X

сума([],N) :- N#=0.
сума([N|X],Сума) :- сума(X,Сума-N).

% Разбира се не е проблем да сметнем сумата на списък с известни
% елементи:

%% ?- сума([8000,400,30,1],Сума).
%% Сума = 8431.

% По-интересно обаче е това, че съгласно условието за пълна
% коректност може да прилагаме този предикат и към списъци, чиито
% елементи са неизвестни.  Достатъчно ще бъде, ако дължината на
% списъка е известна:

%% ?- дължина(X, 3), сума(X, 5).
%% X = [_18300, _18306, _18312],
%% _18336 + _18300 #= 5,
%% _18312 + _18306 #= _18336

% Няма как обаче да използваме този предикат в случая, когато сумата
% е известна, а списъкът напълно неизвестен.  Поглеждайки какво става
% при рекурсията с втория аргумент на предиката сума виждаме, че Сума
% става Сума-N.  Няма никаква причина това да не може да става до
% безкрай.

% Ако искаме да направим предикат, който може да работи в обратната
% посока, можем да дефинираме предикат за сума на положителни числа:

% сума_положителни(X,N) - N е сумата на елементите на X, X е списък
%                         от положителни цели числа
%
% Условие: Известно е ограничение отгоре за дължината на X или за
%          стойността на N

сума_положителни([],N) :- N#=0.
сума_положителни([N|X],Сума) :-
    Сума #> 0, N #> 0, сума_положителни(X,Сума-N).

% По-горе условието Сума #> 0 от математическа гледна точка е
% ненужно.  Именно то обаче прави рекурсията крайна в случая, когато
% е известна сумата, а не списъка.  Да видим как работи този
% предикат:

%% ?- сума_положителни([8000,400,30,1],Сума).
%% Сума = 8431.

%% ?- сума_положителни(X,4).
%% X = [4] ;
%%
%% X = [_4126, _4132],
%% _4126 in 1..3,
%% _4126+_4132#=4,
%% _4132 in 1..3 ;
%%
%% X = [_9142, _9148, _9154],
%% _9142 in 1..2,
%% 4#=_9142+_9148+_9154,
%% _9142+_9148#=_9228,
%% _9148 in 1..2,
%% _9228 in 2..3,
%% _9154 in 1..2 ;
%%
%% X = [1, 1, 1, 1] ;
%% false.

% Виждаме че предикатър работи.  Получихме четири отговора, които
% вярно обхващат всички възможни списъци от положителни цели числа,
% чиято сума е равна на 4.

% Това, че вместо красиви списъци от числа получихме като отговор
% грозни уравнения е всъщност едно от основните преимущества на
% логическото програмиране – възможността да работим с ненапълно
% известни обекти, в частност с ненапълно известни числа.

% При използване на традиционен език за програмиране ще ни се наложи
% да конкретизираме стойностите на променливите в програмата,
% например в горния случай да конкретизираме стойностите на
% елементите на спъсъка.  Ако търсим списък, изпълняващ някакви
% допълнителни условия, ще трябва да проверим всеки един от така
% получилите се списъци.  Но тъй като има твърде много списъци, чиято
% сума е дадено число, това ще доведе до комбинаторен взрив и
% програмата никога няма да даде резултат.

% Тъй като пролог работи с уравнения, а не с конкретни стойности на
% числата, то изпълнението на програмата е по-бавно, отколкото
% изпълнението при един традиционен език за програмиране.  Работата с
% неопределени стойности обаче ни позволява да избегнем комбинаторния
% взрив и програмата дава резултат.

% Обикновено след като сме казали на компютъра всички условия, които
% дадени числа трябва да удовлетворяват, идва момент да поискаме от
% компютъра да даде конкретни стойности на неизвестните, от които се
% интересуваме.  Правим това посредством предиката label:

% label([X1,X2,X3,..,XN]) - аргументът е списък от N променливи. С
%                           предиката label казваме на компютъра, че
%                           искаме тези променливи да получат
%                           конкретни стойности.  Компютърът ще реши
%                           известните до момента уравнения и
%                           неравенства, и ще намери такива
%                           стойности.
%
% Условие: трябва да са известни някакви крайни области, в които
%          трябва да се търсят стойности на X1,X2,..,XN.

% Пример без label:

%% ?- N #> 0, N #< 4.
%% N in 1..3.

% Същото с добавен label:

%% ?- N #> 0, N #< 4, label([N]).
%% N = 1 ;
%% N = 2 ;
%% N = 3.

% Без label:

%% ?- A #> 0, B #> 0, A+B #<5.
%% A in 1..3,
%% A+B#=_80970,
%% B in 1..3,
%% _80970 in 2..4.

% Същото с добавен label:

%% ?- A #> 0, B #> 0, A+B #<5, label([A,B]).
%% A = B, B = 1 ;
%% A = 1, B = 2 ;
%% A = 1, B = 3 ;
%% A = 2, B = 1 ;
%% A = B, B = 2 ;
%% A = 3, B = 1.

% Предикатът label може да се използва само тогава, когато е известна
% крайна област, в която компютърът може да търси решение:

%% ?- N #> 0, label([N]).
%% ERROR: Arguments are not sufficiently instantiated

% Ето как работи горното извикване на сума_положителни(X,4), ако
% добавим предиката label:

%% ?- сума_положителни(X,4), label(X).
%% X = [4] ;
%% X = [1, 3] ;
%% X = [2, 2] ;
%% X = [3, 1] ;
%% X = [1, 1, 2] ;
%% X = [1, 2, 1] ;
%% X = [2, 1, 1] ;
%% X = [1, 1, 1, 1] ;
%% false.

% Ето илюстрация на това, че можем да добавяме последователно няколко
% условия, които намаляват съществено областта на търсене, и едва
% това да поискаме с label конкретни стойности.  След изпълнението на
% сума_положителни списъкът все още няма да има конкретни стойности:

%% ?- сума_положителни(X,5), дължина(X,3), label(X).
%% X = [1, 1, 3] ;
%% X = [1, 2, 2] ;
%% X = [1, 3, 1] ;
%% X = [2, 1, 2] ;
%% X = [2, 2, 1] ;
%% X = [3, 1, 1] ;
%% false.

% Когато търси решения, пролог не винаги ще пробва всички възможно
% елементи на крайната област.  Да попитаме например дали има цели
% числа X, Y и Z, които са между 1 и 10000 и са решение на
% диофантовото уравнение

% (X+1000)³ - 2*(Y+1000)³ = Z

%% ?- 1#=<X,1#=<Y,1#=<Z,X#=<10000,Y#=<10000,Z#=<10000,
%%    (X+1000)^3 - 2*(Y+1000)^3 #= Z, label([X,Y,Z]).
%% false.

% Да забележим, че за всяка променлива има 10000 възможни стойности.
% Следователно вариациите на (X,Y,Z) са 1_000_000_000_000.  Това е е
% повече, отколкото компютърът може да провери за разумно време.
% Въпреки това пролог намира отговора сравнително бързо, защото се
% сеща, че не е нужно да проверява всички вариации.

% факториел(N,F) - F = N!
%
% Условие: известно е N

факториел(N,F) :- N#=0, F#=1.
факториел(N,F) :- N #>= 0, F #= F1*N, N1 #= N-1, факториел(N1,F1).

% Примери:

%% ?- факториел(0,F).
%% F = 1 ;
%% false.

%% ?- факториел(1,F).
%% F = 1 ;
%% false.

%% ?- факториел(5,F).
%% F = 120 ;
%% false.

%% ?- факториел(120,F).
%% F = 66895029134491270575881180540903725867527463331380298102956713523016335572449629893668741652719849813081576378932140905525344085894081218598f98481114389650005964960521256960000000000000000000000000000 ;
%% false.

% Да изведем условието за коректност на този предикат.  Първата
% клауза не ни интересува, защото свежда към предикати за
% ограничение.  Във втората клауза при рекурсивното извикване първият
% аргумент става с единица по-малък.  Но тъй като има условие този
% аргумент да бъде положително число, то това не може да става до
% безкрайност.  Така получаваме условие за коректност да бъде
% известно ограничение отгоре за първият аргумент.

% По-трудно се доказва защо предикатът може да работи и в обратната
% посока.  Например може да попитаме кое число има факториел 120:

%% ?- факториел(F,120).
%% F = 5 

% Може дори да попитаме кои числа имат факториел между 10^70 и 10^80:

%% ?- F #>= 10^70, F #=< 10^80, факториел(N,F).
%% F = 230843697339241380472092742683027581083278564571807941132288000000000000,
%% N = 54 ;
%% F = 12696403353658275925965100847566516959580321051449436762275840000000000000,
%% N = 55 ;
%% F = 710998587804863451854045647463724949736497978881168458687447040000000000000,
%% N = 56 ;
%% F = 40526919504877216755680601905432322134980384796226602145184481280000000000000,
%% N = 57 ;
%% F = 2350561331282878571829474910515074683828862318181142924420699914240000000000000,
%% N = 58 ;
%% false.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% БЕЗКРАЙНИ ГЕНЕРАТОРИ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Безкрайните генератори нямат практически приложения, но на изпита
% по ЛП те често се използват за задачи.

% Методите за доказателство на коректност, които използвахме досега,
% не могат да се прилагат за безкрайни генератори.  За да се напише
% правилна дефиниция на безкраен генератор, има два подхода:
%
% 1. Да знаем как работи пролог.  Този подход по-традиционен, но има
%    два недостатъка: използваме пролог не като логически език и
%    обръщаме голямо внимание на особености на пролог, които
%    най-вероятно няма да са в сила при бъдещите езици за логическо
%    програмиране.
%
% 2. Да сведем дефинирането на безкраен генератор към нещата, което
%    вече знаем как се правят.  За щастие това не е трудно.

% Нека имаме следната задача.  Да дефинираме предикат p(X,Y), който
% по дадено X намира Y и от дефиницията на предиката следва, че за
% дадено конкретно X има безброй много възможни стойности за Y.

% Решаваме задачата така.  Най-напред си измисляме предикат
% p'(N,X,Y), такъв че
%
%  1. p(X,Y) ⇔ ∃n∈ℕ p'(n,X,Y)
%  2. За всяко X и n∈ℕ съществуват краен брой Y, такива че p'(n,X,Y)

% Тъй като p' генерира краен брой решения, то можем да го дефинираме
% по начина, който вече знаем.  А дефиницията на p изглежда така:

%  p(X,Y) :- nat(N), p'(N,X,Y).

% Дефиницията на предиката nat (генератор на естествените числа)
% просто запомняме наизуст:

nat(N) :- N#=0 ; nat(N-1).

%% ?- nat(N).
%% N = 0 ;
%% N = 1 ;
%% N = 2 ;
%% N = 3 ;
%% N = 4 ;
%% N = 5 ;
%% N = 6 ;
%% N = 7 ;
%% N = 8 ;
%% N = 9 ;
%% ...

% Пример 1.  Да се дефинира генератор на двойките [A,B] от естествени
% числа.

% Ето един неправилен, но често срещащ се на изпита начин:
%
% двойка естествени([N1,N2]) :- nat(N1), nat(N2).

% Горната дефиниция няма вида
%
%     безкраен_генератор(X) :- nat(N), краен_генератор(N, X).
%
% защото nat(N2) не е краен генератор.  Ето един правилен начин:

двойка_естествени([N1,N2]) :- nat(Сума),
		 	      N1 #>= 0, N2 #>= 0, Сума #= N1+N2,
			      label([N1,N2]).

% Горната дефиниция е правилна, защото
%
% 1. [N1,N2] е двойка от естествени числа тогава и само тогава, когато
%    N1 и N2 са неотрицателни и за някое естествено число N е вярно,
%    че N е сумата на N1 и N2.
%
% 2. За всяко N има краен брой двойки от естествени числа [N1,N2], за
%    които сумата на N1 и N2 е N

% Ето друг начин:

двойка_естествени2([N1,N2]) :- nat(N),
			       0 #=< N1, N1 #=< N, 0 #=< N2, N2 #=< N,
			       label([N1,N2]).

% Горната дефиниция е правилна, защото
%
% 1. [N1,N2] е двойка от естествени числа тогава и само тогава, когато
%    за някое естествено число N е вярно, че N1 и N2 са между 0 и N.
%
% 2. За всяко N има краен брой двойки [N1,N2], за които N1 и N2 са
%    между 0 и N

% Пример 2.  Да се дефинира предикат, който генерира всички списъци от
% естествени числа

% Най-напред ще си дефинираме следния помощен предикат:

% естествени_до(N,X) – елементите на X са естествени числа, по-малки
%                      или равни на N
%
% Условие: известно е ограничение отгоре за дължината на X

естествени_до(_,[]).
естествени_до(N,[K|X]) :- 0 #=< K, K #=< N, естествени_до(N,X).

% списък_естествени(X) - X е списък от естествени числа
%                        (безкраен генератор)

списък_естествени(X) :- nat(N),
			Дължина #=< N,
			дължина(X, Дължина),
			естествени_до(N, X),
			label(X).

% Горната дефиниция е вярна, защото:
%
%  1. X е списък от естествени числа тогава и само тогава, когато за
%     някое естествено число N списъкът X има дължина по-малка или
%     равна на N и всички елементи на X са по-малки или равни на N.
%
%  2. За всяко естествено N има краен брой списъци X, такива че
%     дължината им е ≦N и елементите им са естествени числа ≦N
